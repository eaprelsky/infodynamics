# –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –¥–∏–Ω–∞–º–∏–∫–∏
## –ó–∞–¥–∞—á–∞ 2.1.4 - –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –∞—Å–ø–µ–∫—Ç –≤ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—É—é –¥–∏–Ω–∞–º–∏–∫—É

**–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è:** –Ø–Ω–≤–∞—Ä—å 2025  
**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ó–ê–í–ï–†–®–ï–ù–û  
**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–æ–±–µ–ª:** –≠–Ω–µ—Ä–≥–µ—Ç–∏–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –Ω–µ –±—ã–ª–∞ —É—á—Ç–µ–Ω–∞ –≤ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –º–æ–¥–µ–ª—è—Ö

---

## üéØ –¶–µ–ª—å

–°–æ–∑–¥–∞—Ç—å –ø–æ–ª–Ω—É—é —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫—É—é –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –¥–∏–Ω–∞–º–∏–∫–∏, –æ–ø–∏—Å—ã–≤–∞—é—â—É—é:
- –≠–Ω–µ—Ä–≥–æ–∑–∞—Ç—Ä–∞—Ç—ã –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (ATP –≤ –Ω–µ–π—Ä–æ–Ω–∞—Ö)
- –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–æ–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
- –ü—Ä–∏–Ω—Ü–∏–ø—ã —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–æ–π —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
- –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∏ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º

---

## ‚ö° –ù–µ–π—Ä–æ–±–∏–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –æ—Å–Ω–æ–≤—ã —ç–Ω–µ—Ä–≥–µ—Ç–∏–∫–∏

### 1. –ú–æ–∑–≥ –∫–∞–∫ —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞

**–ë–∞–∑–æ–≤—ã–µ —Ñ–∞–∫—Ç—ã:**
- –ú–æ–∑–≥ –ø–æ—Ç—Ä–µ–±–ª—è–µ—Ç ~20% –æ–±—â–µ–π —ç–Ω–µ—Ä–≥–∏–∏ –æ—Ä–≥–∞–Ω–∏–∑–º–∞
- –ú–∞—Å—Å–∞ –º–æ–∑–≥–∞ ~2% –æ—Ç –º–∞—Å—Å—ã —Ç–µ–ª–∞
- –ü–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ: ~20W –≤ –ø–æ–∫–æ–µ, –¥–æ 25-30W –ø—Ä–∏ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ–π —Ä–∞–±–æ—Ç–µ
- –ù–µ–π—Ä–æ–Ω—ã –ø–æ—Ç—Ä–µ–±–ª—è—é—Ç ~4.7√ó10‚Åª¬π¬≤ cal/spike (–≥–ª—é–∫–æ–∑–∞ ‚Üí ATP)

**–≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ—Ü–µ—Å—Å—ã:**
```python
class NeuralEnergyModel:
    """–ú–æ–¥–µ–ª—å —ç–Ω–µ—Ä–≥–æ–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è –Ω–µ–π—Ä–æ–Ω–Ω–æ–π —Å–µ—Ç–∏"""
    
    def __init__(self):
        # –ë–∞–∑–æ–≤–æ–µ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ (–≤ –î–∂–æ—É–ª—è—Ö)
        self.baseline_power = 20.0  # –í—Ç (—Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–∫–æ—è)
        self.max_power = 30.0       # –í—Ç (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞)
        
        # –≠–Ω–µ—Ä–≥–∏—è –Ω–∞ spike –Ω–µ–π—Ä–æ–Ω–∞
        self.energy_per_spike = 4.7e-12 * 4184  # –î–∂–æ—É–ª–∏ (cal ‚Üí J)
        
        # –≠–Ω–µ—Ä–≥–∏—è –Ω–∞ —Å–∏–Ω–∞–ø—Ç–∏—á–µ—Å–∫—É—é –ø–µ—Ä–µ–¥–∞—á—É
        self.energy_per_synapse = 1e-15  # –î–∂–æ—É–ª–∏
        
        # –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫–∏
        self.processing_efficiency = 0.25  # 25% (–æ—Å—Ç–∞–ª—å–Ω–æ–µ - —Ç–µ–ø–ª–æ)
    
    def calculate_processing_energy(
        self,
        neural_activity: float,      # [0,1] —É—Ä–æ–≤–µ–Ω—å –Ω–µ–π—Ä–æ–Ω–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        cognitive_load: float,       # [0,‚àû] –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞
        duration_seconds: float      # –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
    ) -> Dict[str, float]:
        """
        –†–∞—Å—á–µ—Ç —ç–Ω–µ—Ä–≥–æ–∑–∞—Ç—Ä–∞—Ç –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        """
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å —Å–≤–µ—Ä—Ö baseline
        additional_power = (self.max_power - self.baseline_power) * neural_activity
        
        # –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞ –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—É—é –Ω–∞–≥—Ä—É–∑–∫—É (–ø–µ—Ä–µ–≥—Ä—É–∑–∫–∞ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ)
        load_multiplier = 1.0 + 0.5 * np.tanh(cognitive_load - 1.0)
        
        # –û–±—â–∞—è –º–æ—â–Ω–æ—Å—Ç—å
        total_power = (self.baseline_power + additional_power) * load_multiplier
        
        # –û–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è
        total_energy = total_power * duration_seconds
        
        # –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è (–Ω–∞ –ø–æ–ª–µ–∑–Ω—É—é —Ä–∞–±–æ—Ç—É)
        useful_energy = total_energy * self.processing_efficiency
        
        # –¢–µ–ø–ª–æ–≤—ã–µ –ø–æ—Ç–µ—Ä–∏
        heat_loss = total_energy * (1 - self.processing_efficiency)
        
        return {
            'total_energy_joules': total_energy,
            'useful_energy_joules': useful_energy,
            'heat_loss_joules': heat_loss,
            'power_watts': total_power,
            'efficiency': self.processing_efficiency,
            'load_multiplier': load_multiplier
        }
```

### 2. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ —Ç–∏–ø—ã –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤

```python
class CognitiveEnergyProfile:
    """–≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ—Ñ–∏–ª–∏ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤"""
    
    ENERGY_PROFILES = {
        'attention_focus': {
            'base_power_factor': 1.2,      # 20% –≤—ã—à–µ baseline
            'duration_efficiency': 0.9,    # –í—ã—Å–æ–∫–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
            'fatigue_rate': 0.05           # –ú–µ–¥–ª–µ–Ω–Ω–æ–µ —É—Ç–æ–º–ª–µ–Ω–∏–µ
        },
        'working_memory': {
            'base_power_factor': 1.5,      # 50% –≤—ã—à–µ baseline
            'duration_efficiency': 0.7,    # –°—Ä–µ–¥–Ω—è—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
            'fatigue_rate': 0.15          # –ë—ã—Å—Ç—Ä–æ–µ —É—Ç–æ–º–ª–µ–Ω–∏–µ
        },
        'long_term_retrieval': {
            'base_power_factor': 1.1,      # 10% –≤—ã—à–µ baseline
            'duration_efficiency': 0.95,   # –û—á–µ–Ω—å —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ
            'fatigue_rate': 0.02          # –û—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ–µ —É—Ç–æ–º–ª–µ–Ω–∏–µ
        },
        'complex_reasoning': {
            'base_power_factor': 1.8,      # 80% –≤—ã—à–µ baseline
            'duration_efficiency': 0.6,    # –ù–∏–∑–∫–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
            'fatigue_rate': 0.25          # –û—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ–µ —É—Ç–æ–º–ª–µ–Ω–∏–µ
        },
        'creative_thinking': {
            'base_power_factor': 1.4,      # 40% –≤—ã—à–µ baseline
            'duration_efficiency': 0.5,    # –ù–∏–∑–∫–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (–º–Ω–æ–≥–æ "–º—É—Å–æ—Ä–∞")
            'fatigue_rate': 0.20          # –ë—ã—Å—Ç—Ä–æ–µ —É—Ç–æ–º–ª–µ–Ω–∏–µ
        },
        'automatic_processing': {
            'base_power_factor': 0.9,      # 10% –Ω–∏–∂–µ baseline
            'duration_efficiency': 0.98,   # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
            'fatigue_rate': 0.01          # –ü–æ—á—Ç–∏ –Ω–µ—Ç —É—Ç–æ–º–ª–µ–Ω–∏—è
        }
    }
    
    def get_energy_cost(self, process_type: str, duration: float) -> float:
        """–ü–æ–ª—É—á–∏—Ç—å —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫—É—é —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ—Ü–µ—Å—Å–∞"""
        if process_type not in self.ENERGY_PROFILES:
            process_type = 'working_memory'  # default
        
        profile = self.ENERGY_PROFILES[process_type]
        
        # –ë–∞–∑–æ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å
        base_cost = 20.0 * profile['base_power_factor'] * duration
        
        # –£—á–µ—Ç —É—Ç–æ–º–ª–µ–Ω–∏—è (—ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —Ä–æ—Å—Ç)
        fatigue_penalty = 1.0 + profile['fatigue_rate'] * (np.exp(duration / 3600) - 1)
        
        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
        total_cost = base_cost * fatigue_penalty / profile['duration_efficiency']
        
        return total_cost
```

---

## ‚ö° –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –∞–Ω–∞–ª–æ–≥–∏ —ç–ª–µ–∫—Ç—Ä–æ—Ç–µ—Ö–Ω–∏–∫–∏

### 1. –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å

```python
def calculate_information_power(U_info: float, I_info: float, efficiency: float = 1.0) -> Dict[str, float]:
    """
    –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏ —Å —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–æ–π
    P = U √ó I
    """
    # –ê–∫—Ç–∏–≤–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å (–ø–æ–ª–µ–∑–Ω–∞—è —Ä–∞–±–æ—Ç–∞)
    P_active = U_info * I_info * efficiency
    
    # –†–µ–∞–∫—Ç–∏–≤–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å (–ø–æ—Ç–µ—Ä–∏ –Ω–∞ —Ä–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–∞—Ö)
    P_reactive = U_info * I_info * (1 - efficiency)
    
    # –ü–æ–ª–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
    P_apparent = U_info * I_info
    
    return {
        'active_power': P_active,           # –ü–æ–ª–µ–∑–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è —Ä–∞–±–æ—Ç–∞
        'reactive_power': P_reactive,       # –ü–æ—Ç–µ—Ä–∏ (—Ç–µ–ø–ª–æ, –ø–æ–º–µ—Ö–∏)
        'apparent_power': P_apparent,       # –û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
        'power_factor': efficiency          # –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –º–æ—â–Ω–æ—Å—Ç–∏
    }

def information_energy_in_components(R_info: float, L_info: float, C_info: float, 
                                   I_info: float, U_info: float) -> Dict[str, float]:
    """
    –≠–Ω–µ—Ä–≥–∏—è, –∑–∞–ø–∞—Å–µ–Ω–Ω–∞—è –≤ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞—Ö
    """
    # –≠–Ω–µ—Ä–≥–∏—è –≤ —Ä–µ–∑–∏—Å—Ç–∏–≤–Ω–æ–º —ç–ª–µ–º–µ–Ω—Ç–µ (—Ä–∞—Å—Å–µ–∏–≤–∞–µ—Ç—Å—è –∫–∞–∫ —Ç–µ–ø–ª–æ)
    E_resistive = I_info ** 2 * R_info  # –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å –ø–æ—Ç–µ—Ä—å
    
    # –≠–Ω–µ—Ä–≥–∏—è –≤ –∏–Ω–¥—É–∫—Ç–∏–≤–Ω–æ–º —ç–ª–µ–º–µ–Ω—Ç–µ (–∏–Ω–µ—Ä—Ü–∏—è, –∑–∞–¥–µ—Ä–∂–∫–∏)
    E_inductive = 0.5 * L_info * I_info ** 2
    
    # –≠–Ω–µ—Ä–≥–∏—è –≤ –µ–º–∫–æ—Å—Ç–Ω–æ–º —ç–ª–µ–º–µ–Ω—Ç–µ (–Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è)
    E_capacitive = 0.5 * C_info * U_info ** 2
    
    # –û–±—â–∞—è –∑–∞–ø–∞—Å–µ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
    E_stored = E_inductive + E_capacitive
    
    return {
        'resistive_loss': E_resistive,      # –ü–æ—Ç–µ—Ä–∏ (–Ω–µ–æ–±—Ä–∞—Ç–∏–º—ã–µ)
        'inductive_energy': E_inductive,    # –≠–Ω–µ—Ä–≥–∏—è –∏–Ω–µ—Ä—Ü–∏–∏
        'capacitive_energy': E_capacitive,  # –≠–Ω–µ—Ä–≥–∏—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è
        'total_stored': E_stored            # –û–±—â–∞—è –∑–∞–ø–∞—Å–µ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
    }
```

### 2. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –±–∞–ª–∞–Ω—Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã

```python
class InformationEnergyBalance:
    """–≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –±–∞–ª–∞–Ω—Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã"""
    
    def __init__(self, neural_energy_model: NeuralEnergyModel):
        self.neural_model = neural_energy_model
        self.energy_history = []
    
    def energy_conservation_law(
        self,
        E_input: float,          # –í—Ö–æ–¥–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
        E_processing: float,     # –≠–Ω–µ—Ä–≥–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏  
        E_stored: float,         # –ó–∞–ø–∞—Å–µ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
        E_output: float,         # –í—ã—Ö–æ–¥–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
        E_loss: float            # –ü–æ—Ç–µ—Ä–∏
    ) -> Dict[str, float]:
        """
        –ó–∞–∫–æ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
        E_input = E_processing + E_stored + E_output + E_loss
        """
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞
        E_total_consumption = E_processing + E_stored + E_output + E_loss
        energy_balance_error = abs(E_input - E_total_consumption)
        
        # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
        useful_energy = E_output + E_stored  # –ü–æ–ª–µ–∑–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
        efficiency = useful_energy / E_input if E_input > 0 else 0
        
        # –ü–æ—Ç–µ—Ä–∏ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
        loss_percentage = E_loss / E_input * 100 if E_input > 0 else 0
        
        return {
            'energy_balance_error': energy_balance_error,
            'efficiency_percent': efficiency * 100,
            'loss_percentage': loss_percentage,
            'useful_energy': useful_energy,
            'energy_conservation_valid': energy_balance_error < 0.01 * E_input
        }
    
    def cognitive_energy_budget(
        self,
        available_energy: float,     # –î–æ—Å—Ç—É–ø–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è (–î–∂)
        task_demands: List[Dict],    # –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á —Å —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º–∏
        time_window: float           # –í—Ä–µ–º–µ–Ω–Ω–æ–µ –æ–∫–Ω–æ (—Å–µ–∫)
    ) -> Dict[str, any]:
        """
        –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–æ–≥–æ –±—é–¥–∂–µ—Ç–∞ –º–µ–∂–¥—É –∑–∞–¥–∞—á–∞–º–∏
        """
        total_demand = sum(task['energy_cost'] for task in task_demands)
        
        if total_demand <= available_energy:
            # –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–Ω–µ—Ä–≥–∏–∏ –¥–ª—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
            allocation = task_demands.copy()
            remaining_energy = available_energy - total_demand
            
        else:
            # –ù–µ—Ö–≤–∞—Ç–∫–∞ —ç–Ω–µ—Ä–≥–∏–∏ - –Ω—É–∂–Ω–∞ –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏—è
            # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É / —ç–Ω–µ—Ä–≥–æ–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—é
            sorted_tasks = sorted(
                task_demands, 
                key=lambda x: x.get('priority', 1.0) / x['energy_cost'],
                reverse=True
            )
            
            allocation = []
            remaining_energy = available_energy
            
            for task in sorted_tasks:
                if task['energy_cost'] <= remaining_energy:
                    allocation.append(task)
                    remaining_energy -= task['energy_cost']
                else:
                    # –ß–∞—Å—Ç–∏—á–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
                    if task.get('divisible', False):
                        partial_task = task.copy()
                        completion_ratio = remaining_energy / task['energy_cost']
                        partial_task['energy_cost'] = remaining_energy
                        partial_task['completion_ratio'] = completion_ratio
                        allocation.append(partial_task)
                        remaining_energy = 0
                    break
        
        return {
            'allocated_tasks': allocation,
            'remaining_energy': remaining_energy,
            'total_allocated': sum(task['energy_cost'] for task in allocation),
            'energy_deficit': max(0, total_demand - available_energy),
            'allocation_efficiency': sum(task['energy_cost'] for task in allocation) / available_energy
        }
```

---

## üîÑ –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –º–æ–¥–µ–ª–∏

### 1. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–∫–æ–Ω –û–º–∞

```python
def energetic_ohms_law(
    U_info: float,          # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ
    R_info: float,          # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ
    L_info: float,          # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –∏–Ω–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
    C_info: float,          # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –µ–º–∫–æ—Å—Ç—å
    frequency: float = 0,   # –ß–∞—Å—Ç–æ—Ç–∞ (–¥–ª—è AC –∞–Ω–∞–ª–∏–∑–∞)
    time_duration: float = 1.0  # –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ—Ü–µ—Å—Å–∞
) -> Dict[str, float]:
    """
    –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π —Ü–µ–ø–∏
    """
    if frequency == 0:  # DC –∞–Ω–∞–ª–∏–∑
        I_info = U_info / R_info
        
        # –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
        P_resistive = I_info ** 2 * R_info  # –ü–æ—Ç–µ—Ä–∏ –≤ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–∏
        P_input = U_info * I_info            # –í—Ö–æ–¥–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
        
        # –≠–Ω–µ—Ä–≥–∏—è –∑–∞ –≤—Ä–µ–º—è duration
        E_dissipated = P_resistive * time_duration  # –†–∞—Å—Å–µ—è–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
        E_input_total = P_input * time_duration     # –û–±—â–∞—è –≤—Ö–æ–¥–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
        
        # –ó–∞–ø–∞—Å–µ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è (–¥–ª—è C –∏ L - –Ω–æ–ª—å –≤ DC)
        E_stored = 0
        
    else:  # AC –∞–Ω–∞–ª–∏–∑
        omega = 2 * np.pi * frequency
        
        # –ò–º–ø–µ–¥–∞–Ω—Å
        Z_total = complex(R_info, omega * L_info - 1/(omega * C_info))
        I_info_complex = U_info / Z_total
        I_info = abs(I_info_complex)
        
        # –ê–∫—Ç–∏–≤–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å (—Ç–æ–ª—å–∫–æ —Ä–µ–∑–∏—Å—Ç–∏–≤–Ω–∞—è —á–∞—Å—Ç—å)
        P_active = I_info ** 2 * R_info
        
        # –†–µ–∞–∫—Ç–∏–≤–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
        X_total = omega * L_info - 1/(omega * C_info)  # –†–µ–∞–∫—Ç–∏–≤–Ω–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ
        P_reactive = I_info ** 2 * abs(X_total)
        
        # –ü–æ–ª–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
        P_apparent = U_info * I_info
        
        # –≠–Ω–µ—Ä–≥–∏—è –∑–∞ –ø–µ—Ä–∏–æ–¥
        E_dissipated = P_active * time_duration
        E_reactive = P_reactive * time_duration  # –≠–Ω–µ—Ä–≥–∏—è –∫–æ–ª–µ–±–∞–Ω–∏–π
        
        # –ó–∞–ø–∞—Å–µ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è –≤ —Ä–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–∞—Ö
        E_stored = 0.5 * L_info * I_info ** 2 + 0.5 * C_info * U_info ** 2
    
    return {
        'current': I_info,
        'active_power': P_active if frequency > 0 else P_resistive,
        'reactive_power': P_reactive if frequency > 0 else 0,
        'apparent_power': P_apparent if frequency > 0 else P_input,
        'energy_dissipated': E_dissipated,
        'energy_stored': E_stored,
        'power_factor': P_active / P_apparent if frequency > 0 and P_apparent > 0 else 1.0,
        'efficiency': (P_apparent - P_resistive) / P_apparent if P_apparent > 0 else 0
    }
```

### 2. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä—ã

```python
class EnergeticTransformer:
    """–≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä–∞"""
    
    def __init__(self, transformation_ratio: float, efficiency: float = 0.9):
        self.k = transformation_ratio
        self.Œ∑ = efficiency
        
    def transform_with_energy_analysis(
        self,
        U_input: float,
        I_input: float,
        cognitive_load: float = 1.0
    ) -> Dict[str, float]:
        """
        –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è —Å —É—á–µ—Ç–æ–º —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏—Ö –ø–æ—Ç–µ—Ä—å
        """
        # –í—Ö–æ–¥–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
        P_input = U_input * I_input
        
        # –ò–¥–µ–∞–ª—å–Ω–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è
        U_output_ideal = self.k * U_input
        I_output_ideal = I_input / self.k
        P_output_ideal = U_output_ideal * I_output_ideal  # = P_input
        
        # –†–µ–∞–ª—å–Ω—ã–µ –ø–æ—Ç–µ—Ä–∏
        # 1. –†–µ–∑–∏—Å—Ç–∏–≤–Ω—ã–µ –ø–æ—Ç–µ—Ä–∏ (–∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ)
        resistance_loss = P_input * (1 - self.Œ∑) * cognitive_load
        
        # 2. –ü–æ—Ç–µ—Ä–∏ –Ω–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é (semantic drift, etc.)
        transformation_loss = P_input * 0.05 * (abs(self.k - 1.0))
        
        # 3. –ü–æ—Ç–µ—Ä–∏ –Ω–∞ —á–∞—Å—Ç–æ—Ç—É (–µ—Å–ª–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –º–µ–Ω—è–µ—Ç "—á–∞—Å—Ç–æ—Ç—É" –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏)
        frequency_loss = P_input * 0.02 * (self.k ** 0.5)
        
        total_loss = resistance_loss + transformation_loss + frequency_loss
        
        # –†–µ–∞–ª—å–Ω–∞—è –≤—ã—Ö–æ–¥–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
        P_output_real = P_input - total_loss
        
        # –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø–æ–ª–µ–∑–Ω–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è (—Ä–µ–∞–ª—å–Ω—ã–π)
        efficiency_real = P_output_real / P_input if P_input > 0 else 0
        
        return {
            'U_output': U_output_ideal,
            'I_output': I_output_ideal,
            'P_input': P_input,
            'P_output_ideal': P_output_ideal,
            'P_output_real': P_output_real,
            'total_loss': total_loss,
            'resistance_loss': resistance_loss,
            'transformation_loss': transformation_loss,
            'frequency_loss': frequency_loss,
            'efficiency_ideal': self.Œ∑,
            'efficiency_real': efficiency_real,
            'energy_quality_factor': P_output_real / P_output_ideal
        }
```

### 3. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è –µ–º–∫–æ—Å—Ç—å

```python
class EnergeticCapacitor:
    """–≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏"""
    
    def __init__(self, capacity: float, max_energy: float):
        self.C_info = capacity
        self.max_energy = max_energy  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è —Ö—Ä–∞–Ω–µ–Ω–∏—è
        self.current_energy = 0
        self.current_voltage = 0
    
    def charge_with_energy_tracking(
        self,
        voltage_source: float,
        resistance: float,
        time_step: float,
        available_energy: float
    ) -> Dict[str, float]:
        """
        –ó–∞—Ä—è–¥–∫–∞ —Å —É—á–µ—Ç–æ–º —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
        """
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ä–∞—Å—á–µ—Ç RC –∑–∞—Ä—è–¥–∫–∏
        RC_constant = resistance * self.C_info
        dU_dt = (voltage_source - self.current_voltage) / RC_constant
        
        # –¢—Ä–µ–±—É–µ–º–∞—è —ç–Ω–µ—Ä–≥–∏—è –¥–ª—è –∑–∞—Ä—è–¥–∫–∏
        voltage_increment = dU_dt * time_step
        new_voltage = self.current_voltage + voltage_increment
        
        # –≠–Ω–µ—Ä–≥–∏—è, –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞—è –¥–ª—è —Ç–∞–∫–æ–≥–æ –ø—Ä–∏—Ä–∞—â–µ–Ω–∏—è
        energy_old = 0.5 * self.C_info * self.current_voltage ** 2
        energy_new = 0.5 * self.C_info * new_voltage ** 2
        energy_required = energy_new - energy_old
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
        if energy_required <= available_energy and energy_new <= self.max_energy:
            # –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–Ω–µ—Ä–≥–∏–∏ - –Ω–æ—Ä–º–∞–ª—å–Ω–∞—è –∑–∞—Ä—è–¥–∫–∞
            self.current_voltage = new_voltage
            self.current_energy = energy_new
            energy_consumed = energy_required
            charging_efficiency = 1.0
        else:
            # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è - –∑–∞–º–µ–¥–ª–µ–Ω–Ω–∞—è –∑–∞—Ä—è–¥–∫–∞
            available_voltage_increase = np.sqrt(
                2 * min(available_energy, self.max_energy - self.current_energy) / self.C_info + 
                self.current_voltage ** 2
            ) - self.current_voltage
            
            self.current_voltage += available_voltage_increase
            self.current_energy = 0.5 * self.C_info * self.current_voltage ** 2
            energy_consumed = available_energy
            charging_efficiency = available_voltage_increase / voltage_increment if voltage_increment > 0 else 0
        
        # –¢–æ–∫ –∑–∞—Ä—è–¥–∫–∏
        charging_current = (voltage_source - self.current_voltage) / resistance
        
        return {
            'voltage': self.current_voltage,
            'energy_stored': self.current_energy,
            'charging_current': charging_current,
            'energy_consumed': energy_consumed,
            'charging_efficiency': charging_efficiency,
            'energy_utilization': self.current_energy / self.max_energy,
            'voltage_increment': voltage_increment
        }
    
    def discharge_with_energy_recovery(
        self,
        resistance: float,
        time_step: float
    ) -> Dict[str, float]:
        """
        –†–∞–∑—Ä—è–¥–∫–∞ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏
        """
        RC_constant = resistance * self.C_info
        decay_factor = np.exp(-time_step / RC_constant)
        
        # –≠–Ω–µ—Ä–≥–∏—è –¥–æ —Ä–∞–∑—Ä—è–¥–∫–∏
        energy_before = self.current_energy
        
        # –ù–æ–≤–æ–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ –∏ —ç–Ω–µ—Ä–≥–∏—è
        self.current_voltage *= decay_factor
        self.current_energy = 0.5 * self.C_info * self.current_voltage ** 2
        
        # –í—ã—Å–≤–æ–±–æ–∂–¥–µ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
        energy_released = energy_before - self.current_energy
        
        # –ß–∞—Å—Ç—å —ç–Ω–µ—Ä–≥–∏–∏ –º–æ–∂–µ—Ç –±—ã—Ç—å "–ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∞–Ω–∞" (consolidation to LTM)
        recyclable_energy = energy_released * 0.3  # 30% –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ
        lost_energy = energy_released * 0.7        # 70% —Ç–µ—Ä—è–µ—Ç—Å—è
        
        discharge_current = -self.current_voltage / resistance
        
        return {
            'voltage': self.current_voltage,
            'energy_stored': self.current_energy,
            'discharge_current': discharge_current,
            'energy_released': energy_released,
            'recyclable_energy': recyclable_energy,
            'lost_energy': lost_energy,
            'retention_factor': decay_factor,
            'energy_recovery_efficiency': recyclable_energy / energy_released if energy_released > 0 else 0
        }
```

---

## üß† –ö–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã–µ —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã

### 1. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ–∂–∏–º—ã –º–æ–∑–≥–∞

```python
class BrainEnergyModes:
    """–≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã –º–æ–∑–≥–∞"""
    
    ENERGY_MODES = {
        'default_mode': {
            'power_consumption': 20.0,      # –í—Ç
            'information_processing': 0.3,  # –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
            'attention_level': 0.2,
            'fatigue_rate': 0.01
        },
        'focused_attention': {
            'power_consumption': 24.0,
            'information_processing': 1.0,
            'attention_level': 0.9,
            'fatigue_rate': 0.15
        },
        'diffuse_thinking': {
            'power_consumption': 22.0,
            'information_processing': 0.6,
            'attention_level': 0.4,
            'fatigue_rate': 0.05
        },
        'flow_state': {
            'power_consumption': 25.0,
            'information_processing': 1.5,  # –ü–æ–≤—ã—à–µ–Ω–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
            'attention_level': 1.0,
            'fatigue_rate': 0.03           # –ù–∏–∑–∫–æ–µ —É—Ç–æ–º–ª–µ–Ω–∏–µ
        },
        'cognitive_overload': {
            'power_consumption': 28.0,
            'information_processing': 0.4,  # –°–Ω–∏–∂–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
            'attention_level': 0.6,
            'fatigue_rate': 0.4            # –ë—ã—Å—Ç—Ä–æ–µ —É—Ç–æ–º–ª–µ–Ω–∏–µ
        },
        'mental_fatigue': {
            'power_consumption': 18.0,
            'information_processing': 0.2,
            'attention_level': 0.1,
            'fatigue_rate': 0.02
        }
    }
    
    def transition_energy_cost(self, from_mode: str, to_mode: str) -> float:
        """
        –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –º–µ–∂–¥—É —Ä–µ–∂–∏–º–∞–º–∏
        """
        mode_distances = {
            ('default_mode', 'focused_attention'): 2.0,
            ('focused_attention', 'flow_state'): 1.0,
            ('flow_state', 'cognitive_overload'): 3.0,
            ('cognitive_overload', 'mental_fatigue'): 0.5,
            ('mental_fatigue', 'default_mode'): 1.5,
            # –û–±—Ä–∞—Ç–Ω—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã
            ('focused_attention', 'default_mode'): 1.0,
            ('flow_state', 'focused_attention'): 0.5,
            ('cognitive_overload', 'flow_state'): 4.0,
            ('mental_fatigue', 'cognitive_overload'): 2.0,
            ('default_mode', 'mental_fatigue'): 1.0
        }
        
        # –°–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã —è–≤–Ω–æ
        transition_cost = mode_distances.get((from_mode, to_mode), 
                                           mode_distances.get((to_mode, from_mode), 2.0))
        
        return transition_cost
    
    def optimal_mode_sequence(
        self,
        task_sequence: List[Dict],
        total_time_budget: float,
        total_energy_budget: float
    ) -> Dict[str, any]:
        """
        –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ–∂–∏–º–æ–≤ –¥–ª—è –∑–∞–¥–∞—á
        """
        optimal_sequence = []
        current_energy = total_energy_budget
        current_time = 0
        current_mode = 'default_mode'
        
        for task in task_sequence:
            required_processing = task['complexity']
            available_time = min(task['max_duration'], total_time_budget - current_time)
            
            # –í—ã–±–æ—Ä –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ –¥–ª—è –∑–∞–¥–∞—á–∏
            best_mode = None
            best_efficiency = 0
            
            for mode_name, mode_props in self.ENERGY_MODES.items():
                # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è
                switch_cost = self.transition_energy_cost(current_mode, mode_name)
                
                # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á–∏
                task_energy = mode_props['power_consumption'] * available_time + switch_cost
                
                if task_energy <= current_energy:
                    # –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å = –æ–±—Ä–∞–±–æ—Ç–∫–∞ / —ç–Ω–µ—Ä–≥–æ–∑–∞—Ç—Ä–∞—Ç—ã
                    efficiency = (mode_props['information_processing'] * 
                                mode_props['attention_level']) / task_energy
                    
                    if efficiency > best_efficiency:
                        best_efficiency = efficiency
                        best_mode = mode_name
            
            if best_mode:
                # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ
                switch_cost = self.transition_energy_cost(current_mode, best_mode)
                mode_props = self.ENERGY_MODES[best_mode]
                task_energy = mode_props['power_consumption'] * available_time + switch_cost
                
                optimal_sequence.append({
                    'task_id': task['id'],
                    'mode': best_mode,
                    'duration': available_time,
                    'energy_cost': task_energy,
                    'switch_cost': switch_cost,
                    'efficiency': best_efficiency
                })
                
                current_energy -= task_energy
                current_time += available_time
                current_mode = best_mode
            else:
                # –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–Ω–µ—Ä–≥–∏–∏ - –∑–∞–¥–∞—á–∞ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç—Å—è –∏–ª–∏ –æ—Ç–∫–ª–∞–¥—ã–≤–∞–µ—Ç—Å—è
                optimal_sequence.append({
                    'task_id': task['id'],
                    'mode': 'deferred',
                    'reason': 'insufficient_energy'
                })
        
        return {
            'sequence': optimal_sequence,
            'energy_utilized': total_energy_budget - current_energy,
            'time_utilized': current_time,
            'overall_efficiency': sum(s.get('efficiency', 0) for s in optimal_sequence) / len(optimal_sequence)
        }
```

### 2. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —É—Å—Ç–∞–ª–æ—Å—Ç—å –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ

```python
class CognitiveFatigueModel:
    """–ú–æ–¥–µ–ª—å –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–æ–≥–æ —É—Ç–æ–º–ª–µ–Ω–∏—è –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è"""
    
    def __init__(self, max_energy_capacity: float = 100.0):
        self.max_capacity = max_energy_capacity
        self.current_energy = max_energy_capacity
        self.fatigue_level = 0.0
        self.recovery_rate = 0.1  # % –≤ –º–∏–Ω—É—Ç—É
        
    def energy_depletion(
        self,
        task_intensity: float,    # [0,1] –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –∑–∞–¥–∞—á–∏
        duration_minutes: float,
        cognitive_load: float     # [0,‚àû] –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞
    ) -> Dict[str, float]:
        """
        –ò—Å—Ç–æ—â–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á
        """
        # –ë–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∏—Å—Ç–æ—â–µ–Ω–∏—è
        base_depletion_rate = 2.0  # % –≤ –º–∏–Ω—É—Ç—É –ø—Ä–∏ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–µ
        
        # –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –æ—Ç –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏ –∏ –Ω–∞–≥—Ä—É–∑–∫–∏
        intensity_multiplier = 1.0 + 2.0 * task_intensity  # [1, 3]
        load_multiplier = 1.0 + 0.5 * np.tanh(cognitive_load - 1.0)  # [1, 1.5]
        
        # –û–±—â–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∏—Å—Ç–æ—â–µ–Ω–∏—è
        depletion_rate = base_depletion_rate * intensity_multiplier * load_multiplier
        
        # –£—á–µ—Ç —Ç–µ–∫—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è —É—Å—Ç–∞–ª–æ—Å—Ç–∏ (—É—Å—Ç–∞–ª–æ—Å—Ç—å —É—Å–∫–æ—Ä—è–µ—Ç –∏—Å—Ç–æ—â–µ–Ω–∏–µ)
        fatigue_penalty = 1.0 + 2.0 * self.fatigue_level
        
        total_depletion = depletion_rate * fatigue_penalty * duration_minutes
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        energy_lost = min(total_depletion, self.current_energy)
        self.current_energy -= energy_lost
        self.fatigue_level = 1.0 - (self.current_energy / self.max_capacity)
        
        return {
            'energy_lost': energy_lost,
            'current_energy': self.current_energy,
            'fatigue_level': self.fatigue_level,
            'depletion_rate': depletion_rate,
            'fatigue_penalty': fatigue_penalty,
            'energy_percentage': self.current_energy / self.max_capacity * 100
        }
    
    def energy_recovery(
        self,
        rest_type: str,          # 'active_rest', 'passive_rest', 'sleep'
        duration_minutes: float
    ) -> Dict[str, float]:
        """
        –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ —á–µ—Ä–µ–∑ –æ—Ç–¥—ã—Ö
        """
        recovery_rates = {
            'active_rest': 0.05,      # 5% –≤ –º–∏–Ω—É—Ç—É (–ª–µ–≥–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å)
            'passive_rest': 0.1,      # 10% –≤ –º–∏–Ω—É—Ç—É (–º–µ–¥–∏—Ç–∞—Ü–∏—è, —Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–∏–µ)
            'sleep': 0.3,             # 30% –≤ –º–∏–Ω—É—Ç—É (–≥–ª—É–±–æ–∫–∏–π —Å–æ–Ω)
            'micro_break': 0.15       # 15% –≤ –º–∏–Ω—É—Ç—É (–∫–æ—Ä–æ—Ç–∫–∏–µ –ø–µ—Ä–µ—Ä—ã–≤—ã)
        }
        
        recovery_rate = recovery_rates.get(rest_type, 0.1)
        
        # –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–Ω–∏–∂–∞–µ—Ç—Å—è –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–π —É—Å—Ç–∞–ª–æ—Å—Ç–∏
        recovery_efficiency = 1.0 - 0.3 * self.fatigue_level
        
        effective_recovery_rate = recovery_rate * recovery_efficiency
        energy_recovered = effective_recovery_rate * duration_minutes
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        self.current_energy = min(self.max_capacity, self.current_energy + energy_recovered)
        self.fatigue_level = 1.0 - (self.current_energy / self.max_capacity)
        
        return {
            'energy_recovered': energy_recovered,
            'current_energy': self.current_energy,
            'fatigue_level': self.fatigue_level,
            'recovery_efficiency': recovery_efficiency,
            'energy_percentage': self.current_energy / self.max_capacity * 100
        }
    
    def optimal_work_rest_cycle(
        self,
        total_work_duration: float,  # –º–∏–Ω—É—Ç—ã
        task_intensity: float,       # [0,1]
        cognitive_load: float        # [0,‚àû]
    ) -> Dict[str, any]:
        """
        –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª —Ä–∞–±–æ—Ç—ã –∏ –æ—Ç–¥—ã—Ö–∞ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        """
        cycles = []
        remaining_time = total_work_duration
        cycle_count = 0
        
        while remaining_time > 0 and self.current_energy > 20:  # –ú–∏–Ω–∏–º—É–º 20% —ç–Ω–µ—Ä–≥–∏–∏
            cycle_count += 1
            
            # –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∞–±–æ—Ç—ã (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–µ–∫—É—â–µ–π —ç–Ω–µ—Ä–≥–∏–∏)
            optimal_work_time = min(
                25 * (self.current_energy / self.max_capacity),  # Pomodoro —Å –∫–æ—Ä—Ä–µ–∫—Ü–∏–µ–π
                remaining_time
            )
            
            # –°–∏–º—É–ª—è—Ü–∏—è —Ä–∞–±–æ—Ç—ã
            work_result = self.energy_depletion(task_intensity, optimal_work_time, cognitive_load)
            
            # –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ—Ç–¥—ã—Ö–∞
            if cycle_count % 4 == 0:  # –î–ª–∏–Ω–Ω—ã–π –ø–µ—Ä–µ—Ä—ã–≤ –∫–∞–∂–¥—ã–µ 4 —Ü–∏–∫–ª–∞
                rest_duration = 15
                rest_type = 'passive_rest'
            else:
                rest_duration = 5
                rest_type = 'micro_break'
            
            # –°–∏–º—É–ª—è—Ü–∏—è –æ—Ç–¥—ã—Ö–∞
            rest_result = self.energy_recovery(rest_type, rest_duration)
            
            cycles.append({
                'cycle': cycle_count,
                'work_duration': optimal_work_time,
                'rest_duration': rest_duration,
                'rest_type': rest_type,
                'energy_before_work': work_result['current_energy'] + work_result['energy_lost'],
                'energy_after_work': work_result['current_energy'],
                'energy_after_rest': rest_result['current_energy'],
                'productivity_score': optimal_work_time * (1 - work_result['fatigue_level'])
            })
            
            remaining_time -= optimal_work_time
        
        total_productivity = sum(cycle['productivity_score'] for cycle in cycles)
        
        return {
            'cycles': cycles,
            'total_cycles': cycle_count,
            'total_productivity': total_productivity,
            'average_productivity_per_cycle': total_productivity / cycle_count if cycle_count > 0 else 0,
            'final_energy_level': self.current_energy,
            'optimization_efficiency': total_productivity / total_work_duration
        }
```

---

## üìà –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –º–æ–¥–µ–ª—è–º–∏

### 1. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–∫–æ–Ω –û–º–∞ (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π)

```python
def energetic_information_ohm_law(
    U_info: float,
    R_info: float,
    L_info: float,
    C_info: float,
    available_energy: float,    # –î–æ—Å—Ç—É–ø–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
    neural_efficiency: float = 0.25,  # –ù–µ–π—Ä–æ–Ω–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
    frequency: float = 0
) -> Dict[str, float]:
    """
    –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –∑–∞–∫–æ–Ω –û–º–∞ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    """
    # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ä–∞—Å—á–µ—Ç
    if frequency == 0:
        I_info_ideal = U_info / R_info
    else:
        omega = 2 * np.pi * frequency
        Z_total = complex(R_info, omega * L_info - 1/(omega * C_info))
        I_info_ideal = abs(U_info / Z_total)
    
    # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
    P_required = U_info * I_info_ideal  # –¢—Ä–µ–±—É–µ–º–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å
    E_neural_required = P_required / neural_efficiency  # –¢—Ä–µ–±—É–µ–º–∞—è –Ω–µ–π—Ä–æ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
    
    # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
    if E_neural_required <= available_energy:
        # –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–Ω–µ—Ä–≥–∏–∏ - –∏–¥–µ–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞
        I_info_actual = I_info_ideal
        energy_utilization = E_neural_required / available_energy
        performance_factor = 1.0
    else:
        # –ù–µ—Ö–≤–∞—Ç–∫–∞ —ç–Ω–µ—Ä–≥–∏–∏ - —Å–Ω–∏–∂–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        energy_utilization = 1.0
        performance_factor = available_energy / E_neural_required
        I_info_actual = I_info_ideal * performance_factor
    
    # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ—Ç–µ—Ä–∏
    E_useful = I_info_actual * U_info * neural_efficiency
    E_heat_loss = (I_info_actual * U_info) * (1 - neural_efficiency)
    E_total_consumed = min(E_neural_required, available_energy)
    
    return {
        'current_ideal': I_info_ideal,
        'current_actual': I_info_actual,
        'performance_factor': performance_factor,
        'energy_utilization': energy_utilization,
        'energy_consumed': E_total_consumed,
        'useful_energy': E_useful,
        'heat_loss': E_heat_loss,
        'neural_efficiency': neural_efficiency,
        'energy_deficit': max(0, E_neural_required - available_energy)
    }
```

### 2. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä—ã (–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)

```python
def energetic_transformer_integration(
    transformer_chain: List[Dict],  # –¶–µ–ø—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä–æ–≤
    initial_energy: float,
    energy_budget: float
) -> Dict[str, any]:
    """
    –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Ü–µ–ø–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä–æ–≤
    """
    current_energy = initial_energy
    transformation_results = []
    total_energy_loss = 0
    
    for i, transformer in enumerate(transformer_chain):
        # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
        complexity_factor = transformer.get('complexity', 1.0)
        base_energy_cost = 5.0 * complexity_factor  # –ë–∞–∑–æ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å
        
        if current_energy >= base_energy_cost:
            # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
            efficiency = transformer.get('efficiency', 0.9)
            actual_efficiency = efficiency * (current_energy / energy_budget)  # –°–Ω–∏–∂–µ–Ω–∏–µ –ø—Ä–∏ –∏—Å—Ç–æ—â–µ–Ω–∏–∏
            
            energy_consumed = base_energy_cost
            energy_output = energy_consumed * actual_efficiency
            energy_loss = energy_consumed * (1 - actual_efficiency)
            
            current_energy -= energy_consumed
            total_energy_loss += energy_loss
            
            transformation_results.append({
                'transformer_id': i,
                'type': transformer['type'],
                'energy_consumed': energy_consumed,
                'energy_output': energy_output,
                'efficiency': actual_efficiency,
                'energy_loss': energy_loss,
                'remaining_energy': current_energy
            })
        else:
            # –ù–µ–¥–æ—Å—Ç–∞—Ç–æ–∫ —ç–Ω–µ—Ä–≥–∏–∏ - –ø—Ä–æ–ø—É—Å–∫ –∏–ª–∏ —á–∞—Å—Ç–∏—á–Ω–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è
            partial_efficiency = current_energy / base_energy_cost
            
            transformation_results.append({
                'transformer_id': i,
                'type': transformer['type'],
                'status': 'partial' if partial_efficiency > 0.3 else 'skipped',
                'partial_efficiency': partial_efficiency,
                'energy_deficit': base_energy_cost - current_energy
            })
            
            current_energy = 0  # –≠–Ω–µ—Ä–≥–∏—è –∏—Å—á–µ—Ä–ø–∞–Ω–∞
            break
    
    return {
        'transformations': transformation_results,
        'total_energy_consumed': initial_energy - current_energy,
        'total_energy_loss': total_energy_loss,
        'remaining_energy': current_energy,
        'chain_efficiency': (initial_energy - total_energy_loss) / initial_energy if initial_energy > 0 else 0,
        'completion_rate': len([t for t in transformation_results if t.get('status') != 'skipped']) / len(transformer_chain)
    }
```

---

## üî¨ –≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è

### –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ 1: –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å vs –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞
```python
def test_energy_efficiency_vs_load():
    """
    –¢–µ—Å—Ç: –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏ —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–Ω–∏–∂–∞–µ—Ç—Å—è
    """
    loads = np.linspace(0.5, 3.0, 20)
    efficiencies = []
    
    for load in loads:
        result = energetic_information_ohm_law(
            U_info=5.0, R_info=load, L_info=1.0, C_info=2.0,
            available_energy=100.0, neural_efficiency=0.25
        )
        efficiencies.append(result['neural_efficiency'] * result['performance_factor'])
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: –æ–±—Ä–∞—Ç–Ω–∞—è –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è
    correlation = np.corrcoef(loads, efficiencies)[0,1]
    assert correlation < -0.8, "–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ —Å–Ω–∏–∂–∞—Ç—å—Å—è —Å —Ä–æ—Å—Ç–æ–º –Ω–∞–≥—Ä—É–∑–∫–∏"
```

### –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ 2: –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ —Ä–∞–±–æ—Ç—ã
```python
def test_optimal_working_frequency():
    """
    –¢–µ—Å—Ç: —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –¥–ª—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–Ω–µ—Ä–≥–æ–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è
    """
    frequencies = np.logspace(-2, 1, 50)  # 0.01 to 10 Hz
    energy_costs = []
    
    for freq in frequencies:
        result = energetic_information_ohm_law(
            U_info=5.0, R_info=2.0, L_info=1.0, C_info=1.0,
            available_energy=100.0, frequency=freq
        )
        energy_costs.append(result['energy_consumed'])
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: U-–æ–±—Ä–∞–∑–Ω–∞—è –∫—Ä–∏–≤–∞—è —Å –º–∏–Ω–∏–º—É–º–æ–º
    min_idx = np.argmin(energy_costs)
    assert 0 < min_idx < len(frequencies) - 1, "–î–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–∏–Ω–∏–º—É–º"
```

### –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ 3: –ó–∞–∫–æ–Ω —É—Å—Ç–∞–ª–æ—Å—Ç–∏
```python
def test_fatigue_law():
    """
    –¢–µ—Å—Ç: –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ —Å–Ω–∏–∂–∞–µ—Ç—Å—è —Å –∏—Å—Ç–æ—â–µ–Ω–∏–µ–º —ç–Ω–µ—Ä–≥–∏–∏
    """
    fatigue_model = CognitiveFatigueModel(100.0)
    performance_data = []
    
    for session in range(10):  # 10 —Å–µ—Å—Å–∏–π –ø–æ 30 –º–∏–Ω—É—Ç
        result = fatigue_model.energy_depletion(
            task_intensity=0.7, duration_minutes=30, cognitive_load=1.5
        )
        performance = result['current_energy'] / 100.0  # –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        performance_data.append(performance)
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ
    x = np.arange(len(performance_data))
    log_performance = np.log(np.array(performance_data) + 0.01)  # –ò–∑–±–µ–≥–∞–µ–º log(0)
    slope, _ = np.polyfit(x, log_performance, 1)
    assert slope < -0.1, "–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ —Å–Ω–∏–∂–∞—Ç—å—Å—è"
```

---

## üéØ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è

### 1. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ
```python
def design_energy_optimal_curriculum(
    student_energy_profile: Dict,
    course_content: List[Dict],
    time_constraints: Dict
) -> Dict[str, any]:
    """
    –î–∏–∑–∞–π–Ω —É—á–µ–±–Ω–æ–≥–æ –ø–ª–∞–Ω–∞ —Å —É—á–µ—Ç–æ–º —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
    """
    fatigue_model = CognitiveFatigueModel(student_energy_profile['max_capacity'])
    optimized_schedule = []
    
    for week in range(time_constraints['total_weeks']):
        weekly_schedule = []
        
        for day in range(5):  # –†–∞–±–æ—á–∏–µ –¥–Ω–∏
            daily_energy = student_energy_profile['daily_energy_budget']
            fatigue_model.current_energy = daily_energy
            
            # –û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø–æ –¥–Ω—é
            day_result = fatigue_model.optimal_work_rest_cycle(
                total_work_duration=time_constraints['daily_study_hours'] * 60,
                task_intensity=0.7,
                cognitive_load=1.2
            )
            
            weekly_schedule.append({
                'day': day + 1,
                'cycles': day_result['cycles'],
                'productivity': day_result['total_productivity'],
                'energy_efficiency': day_result['optimization_efficiency']
            })
        
        optimized_schedule.append({
            'week': week + 1,
            'daily_schedules': weekly_schedule,
            'weekly_productivity': sum(day['productivity'] for day in weekly_schedule)
        })
    
    return {
        'schedule': optimized_schedule,
        'total_productivity': sum(week['weekly_productivity'] for week in optimized_schedule),
        'average_efficiency': np.mean([
            day['energy_efficiency'] 
            for week in optimized_schedule 
            for day in week['daily_schedules']
        ])
    }
```

### 2. –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤
```python
def interface_energy_monitor(
    user_interactions: List[Dict],
    interface_elements: List[Dict]
) -> Dict[str, any]:
    """
    –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —ç–Ω–µ—Ä–≥–æ–∑–∞—Ç—Ä–∞—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
    """
    total_energy_consumed = 0
    energy_per_element = {}
    efficiency_scores = []
    
    for interaction in user_interactions:
        element_id = interaction['element_id']
        interaction_type = interaction['type']
        duration = interaction['duration_seconds']
        
        # –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
        base_costs = {
            'click': 0.5,
            'type': 2.0,
            'read': 1.0,
            'search': 3.0,
            'navigate': 1.5
        }
        
        complexity_multiplier = interface_elements[element_id].get('complexity', 1.0)
        energy_cost = base_costs.get(interaction_type, 1.0) * complexity_multiplier * duration
        
        total_energy_consumed += energy_cost
        energy_per_element[element_id] = energy_per_element.get(element_id, 0) + energy_cost
        
        # –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å = –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞—è —Ü–µ–ª—å / —ç–Ω–µ—Ä–≥–æ–∑–∞—Ç—Ä–∞—Ç—ã
        goal_achieved = interaction.get('goal_achieved', 0.5)
        efficiency = goal_achieved / energy_cost if energy_cost > 0 else 0
        efficiency_scores.append(efficiency)
    
    # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    high_cost_elements = sorted(
        energy_per_element.items(), 
        key=lambda x: x[1], 
        reverse=True
    )[:5]
    
    recommendations = []
    for element_id, cost in high_cost_elements:
        if cost > np.mean(list(energy_per_element.values())) * 1.5:
            recommendations.append({
                'element_id': element_id,
                'current_cost': cost,
                'recommendation': 'simplify_interaction',
                'potential_saving': cost * 0.3  # 30% –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —ç–∫–æ–Ω–æ–º–∏—è
            })
    
    return {
        'total_energy_consumed': total_energy_consumed,
        'average_efficiency': np.mean(efficiency_scores),
        'energy_per_element': energy_per_element,
        'high_cost_elements': high_cost_elements,
        'optimization_recommendations': recommendations,
        'estimated_energy_savings': sum(rec['potential_saving'] for rec in recommendations)
    }
```

---

## üìà –í–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω—ã–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏

### –ö–æ–ª–∏—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏:
1. **–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å –Ω–µ–π—Ä–æ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏**: r > 0.7 –º–µ–∂–¥—É –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –∏ –∏–∑–º–µ—Ä–µ–Ω–Ω—ã–º–∏ —ç–Ω–µ—Ä–≥–æ–∑–∞—Ç—Ä–∞—Ç–∞–º–∏
2. **–ó–∞–∫–æ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏**: –ü–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å –±–∞–ª–∞–Ω—Å–∞ < 5%
3. **–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –º–æ–¥–µ–ª–∏**: –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ ¬±15%
4. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –£–ª—É—á—à–µ–Ω–∏–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–µ–π –Ω–∞ 20%+ –ø—Ä–∏ —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

### –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏:
1. **–ë–∏–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –¥–∞–Ω–Ω—ã–º fMRI –∏ PET
2. **–ü–æ–≤–µ–¥–µ–Ω—á–µ—Å–∫–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ —É—Å—Ç–∞–ª–æ—Å—Ç–∏
3. **–≠—Ä–≥–æ–Ω–æ–º–∏—á–µ—Å–∫–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –≤ –¥–∏–∑–∞–π–Ω–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤
4. **–û–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –£–ª—É—á—à–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ–±—É—á–µ–Ω–∏—è

---

**–°—Ç–∞—Ç—É—Å:** ‚úÖ **–ó–ê–î–ê–ß–ê 2.1.4 –ó–ê–í–ï–†–®–ï–ù–ê**

–°–æ–∑–¥–∞–Ω–∞ –ø–æ–ª–Ω–∞—è —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –¥–∏–Ω–∞–º–∏–∫–∏ —Å:
- ‚úÖ –ù–µ–π—Ä–æ–±–∏–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–º–∏ –æ—Å–Ω–æ–≤–∞–º–∏ —ç–Ω–µ—Ä–≥–æ–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è
- ‚úÖ –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–º–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è–º–∏ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ (R, L, C, —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä—ã)
- ‚úÖ –ú–æ–¥–µ–ª—è–º–∏ –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–æ–≥–æ —É—Ç–æ–º–ª–µ–Ω–∏—è –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
- ‚úÖ –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–º–∏ —Ä–µ–∂–∏–º–∞–º–∏ –º–æ–∑–≥–∞ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π
- ‚úÖ –≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–º–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è–º–∏
- ‚úÖ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è–º–∏ –≤ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–∏ –∏ UX
- ‚úÖ –ü–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –º–æ–¥–µ–ª—è–º–∏

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–æ–±–µ–ª —É—Å—Ç—Ä–∞–Ω–µ–Ω!** –¢–µ–ø–µ—Ä—å –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –¥–∏–Ω–∞–º–∏–∫–∏ –∏–º–µ–µ—Ç –ø–æ–ª–Ω—É—é —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫—É—é –æ—Å–Ω–æ–≤—É! üöÄ 