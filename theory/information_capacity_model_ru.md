# –ú–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏
## –ó–∞–¥–∞—á–∞ 2.1.3 - –§–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–Ω—è—Ç–∏–µ "–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏"

**–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è:** –Ø–Ω–≤–∞—Ä—å 2025  
**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ó–ê–í–ï–†–®–ï–ù–û  
**–ë–∞–∑–∏—Ä—É–µ—Ç—Å—è –Ω–∞:** Working Memory Research (Miller, Baddeley), Cognitive Overload —Ç–µ–æ—Ä–∏–∏

---

## üéØ –¶–µ–ª—å

–°–æ–∑–¥–∞—Ç—å —Ñ–æ—Ä–º–∞–ª—å–Ω—É—é –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫—É—é –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏ (C_info), –æ–ø–∏—Å—ã–≤–∞—é—â—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö –∞–≥–µ–Ω—Ç–æ–≤ –Ω–∞–∫–∞–ø–ª–∏–≤–∞—Ç—å, —Ö—Ä–∞–Ω–∏—Ç—å –∏ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤—ã–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏ —Å —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏–º–∏ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä–∞–º–∏.

---

## ‚ö° –≠–ª–µ–∫—Ç—Ä–æ—Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –∞–Ω–∞–ª–æ–≥–∏—è

### –≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏–π –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä
–í —ç–ª–µ–∫—Ç—Ä–æ—Ç–µ—Ö–Ω–∏–∫–µ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä –Ω–∞–∫–∞–ø–ª–∏–≤–∞–µ—Ç —ç–Ω–µ—Ä–≥–∏—é –≤ —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–æ–º –ø–æ–ª–µ:

```
C = Q/V (–µ–º–∫–æ—Å—Ç—å = –∑–∞—Ä—è–¥/–Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ)
E = ¬ΩCV¬≤ (–Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è)
I = C √ó dV/dt (—Ç–æ–∫ –∑–∞—Ä—è–¥–∞/—Ä–∞–∑—Ä—è–¥–∞)
X_C = 1/(œâC) (–µ–º–∫–æ—Å—Ç–Ω–æ–µ —Ä–µ–∞–∫—Ç–∏–≤–Ω–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ)
```

**–°–≤–æ–π—Å—Ç–≤–∞:**
- –ù–∞–∫–∞–ø–ª–∏–≤–∞–µ—Ç –∑–∞—Ä—è–¥ –ø—Ä–∏ –ø–æ–¥–∞—á–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è
- –°–æ–ø—Ä–æ—Ç–∏–≤–ª—è–µ—Ç—Å—è –∏–∑–º–µ–Ω–µ–Ω–∏—é –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è
- –°–æ–∑–¥–∞–µ—Ç —Ñ–∞–∑–æ–≤—ã–π —Å–¥–≤–∏–≥ (-90¬∞ –¥–ª—è –∏–¥–µ–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä–∞)
- –í—ã—Å–æ–∫–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –Ω–∞ –Ω–∏–∑–∫–∏—Ö —á–∞—Å—Ç–æ—Ç–∞—Ö, –Ω–∏–∑–∫–æ–µ - –Ω–∞ –≤—ã—Å–æ–∫–∏—Ö

### –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä
–ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –Ω–∞–∫–∞–ø–ª–∏–≤–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø—Ä–∏ –ø–æ–¥–∞—á–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è:

```
C_info = Q_info/U_info (–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –µ–º–∫–æ—Å—Ç—å)
E_info = ¬ΩC_info√óU_info¬≤ (–Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–µ –∑–Ω–∞–Ω–∏—è)
I_info = C_info √ó dU_info/dt (—Å–∫–æ—Ä–æ—Å—Ç—å –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è/–∑–∞–±—ã–≤–∞–Ω–∏—è)
X_C_info = 1/(œâC_info) (—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—é –∑–Ω–∞–Ω–∏–π)
```

---

## üß† –ö–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã–µ –æ—Å–Ω–æ–≤—ã –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏

### 1. Working Memory Model (Baddeley, 2000)

**–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ä–∞–±–æ—á–µ–π –ø–∞–º—è—Ç–∏:**
- **Central Executive**: –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É—é—â–∞—è —Å–∏—Å—Ç–µ–º–∞, —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–Ω–∏–º–∞–Ω–∏–µ–º
- **Phonological Loop**: –í–µ—Ä–±–∞–ª—å–Ω–∞—è –∏ –∞–∫—É—Å—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è (~2 —Å–µ–∫)
- **Visuospatial Sketchpad**: –í–∏–∑—É–∞–ª—å–Ω–æ-–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è (~4 —ç–ª–µ–º–µ–Ω—Ç–∞)
- **Episodic Buffer**: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ (~4 chunks)

**–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –µ–º–∫–æ—Å—Ç–∏:**
```python
class WorkingMemoryCapacity:
    """–ú–æ–¥–µ–ª—å –µ–º–∫–æ—Å—Ç–∏ —Ä–∞–±–æ—á–µ–π –ø–∞–º—è—Ç–∏ –ø–æ Baddeley"""
    
    def __init__(self, individual_differences: Dict[str, float]):
        # –ë–∞–∑–æ–≤—ã–µ –µ–º–∫–æ—Å—Ç–∏ (Miller 7¬±2, Cowan ~4)
        self.phonological_capacity = individual_differences.get('verbal_span', 7) # chunks
        self.visuospatial_capacity = individual_differences.get('visual_span', 4) # elements
        self.episodic_buffer_capacity = individual_differences.get('integration_span', 4) # bindings
        self.executive_efficiency = individual_differences.get('executive_control', 1.0) # multiplier
    
    def total_capacity(self, task_type: str) -> float:
        """–û–±—â–∞—è –µ–º–∫–æ—Å—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∑–∞–¥–∞—á–∏"""
        if task_type == 'verbal':
            return self.phonological_capacity * self.executive_efficiency
        elif task_type == 'visual':
            return self.visuospatial_capacity * self.executive_efficiency
        elif task_type == 'complex':
            return min(
                self.phonological_capacity, 
                self.visuospatial_capacity,
                self.episodic_buffer_capacity
            ) * self.executive_efficiency
        else:
            return (self.phonological_capacity + self.visuospatial_capacity) / 2 * self.executive_efficiency
```

### 2. Long-Term Memory Capacity

**–¢–∏–ø—ã –¥–æ–ª–≥–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç–∏:**
- **Declarative Memory**: –§–∞–∫—Ç—ã –∏ —Å–æ–±—ã—Ç–∏—è (~10¬π‚Åµ bits —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏)
- **Procedural Memory**: –ù–∞–≤—ã–∫–∏ –∏ –ø—Ä–∏–≤—ã—á–∫–∏
- **Semantic Memory**: –ö–æ–Ω—Ü–µ–ø—Ç—É–∞–ª—å–Ω—ã–µ –∑–Ω–∞–Ω–∏—è –∏ –∑–Ω–∞—á–µ–Ω–∏—è

**–§–∞–∫—Ç–æ—Ä—ã, –≤–ª–∏—è—é—â–∏–µ –Ω–∞ –µ–º–∫–æ—Å—Ç—å:**
```python
def calculate_ltm_capacity(
    age: float,
    education_years: float,
    domain_expertise: float,
    general_intelligence: float,
    health_factors: float = 1.0
) -> float:
    """
    –û—Ü–µ–Ω–∫–∞ –µ–º–∫–æ—Å—Ç–∏ –¥–æ–ª–≥–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç–∏
    """
    # –ë–∞–∑–æ–≤–∞—è –µ–º–∫–æ—Å—Ç—å (–Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è)
    base_capacity = 1.0
    
    # –í–æ–∑—Ä–∞—Å—Ç–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è (–ø–∏–∫ –≤ 25-30 –ª–µ—Ç)
    if age <= 30:
        age_factor = 0.8 + 0.4 * (age / 30)
    else:
        age_factor = 1.2 - 0.01 * (age - 30)  # –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ
    
    # –û–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π —Ñ–∞–∫—Ç–æ—Ä
    education_factor = 1.0 + 0.05 * education_years
    
    # –≠–∫—Å–ø–µ—Ä—Ç–∏–∑–∞ –≤ –¥–æ–º–µ–Ω–µ
    expertise_factor = 1.0 + 2.0 * domain_expertise  # –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —Ä–æ—Å—Ç
    
    # –û–±—â–∏–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç
    intelligence_factor = 0.5 + 0.5 * general_intelligence
    
    total_capacity = (
        base_capacity * 
        age_factor * 
        education_factor * 
        expertise_factor * 
        intelligence_factor * 
        health_factors
    )
    
    return max(0.1, total_capacity)
```

### 3. Motivation and Learning Drive

**–í–ª–∏—è–Ω–∏–µ –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –Ω–∞ –µ–º–∫–æ—Å—Ç—å:**
```python
class MotivationalCapacityModulation:
    """–ú–æ–¥—É–ª—è—Ü–∏—è –µ–º–∫–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ –º–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã"""
    
    def __init__(self):
        self.intrinsic_motivation_weight = 0.4
        self.extrinsic_motivation_weight = 0.3
        self.curiosity_weight = 0.2
        self.relevance_weight = 0.1
    
    def calculate_motivation_multiplier(
        self,
        intrinsic_interest: float,        # [0,1] –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∏–Ω—Ç–µ—Ä–µ—Å
        external_rewards: float,          # [0,1] –≤–Ω–µ—à–Ω–∏–µ —Å—Ç–∏–º—É–ª—ã
        curiosity_level: float,           # [0,1] –ª—é–±–æ–∑–Ω–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        personal_relevance: float         # [0,1] –ª–∏—á–Ω–∞—è —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å
    ) -> float:
        """
        –ú–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã–π –º–Ω–æ–∂–∏—Ç–µ–ª—å –µ–º–∫–æ—Å—Ç–∏
        """
        motivation_score = (
            self.intrinsic_motivation_weight * intrinsic_interest +
            self.extrinsic_motivation_weight * external_rewards +
            self.curiosity_weight * curiosity_level +
            self.relevance_weight * personal_relevance
        )
        
        # –ù–µ–ª–∏–Ω–µ–π–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (sigmoid)
        motivation_multiplier = 1 / (1 + np.exp(-5 * (motivation_score - 0.5)))
        
        return 0.5 + 1.5 * motivation_multiplier  # –î–∏–∞–ø–∞–∑–æ–Ω [0.5, 2.0]
```

---

## üßÆ –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏

### –ë–∞–∑–æ–≤–∞—è —Ñ–æ—Ä–º—É–ª–∞:
```
C_info = C_base √ó Memory_Factor √ó Motivation_Factor √ó Organization_Factor

–≥–¥–µ:
C_base = –±–∞–∑–æ–≤–∞—è –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –µ–º–∫–æ—Å—Ç—å –∏–Ω–¥–∏–≤–∏–¥–∞
Memory_Factor = f(WM_capacity, LTM_capacity, age, health)
Motivation_Factor = f(interest, relevance, curiosity, rewards)
Organization_Factor = f(categorization_skills, schema_strength, retrieval_efficiency)
```

### –î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–æ–¥–µ–ª—å:
```python
import numpy as np
from typing import Dict, List, Tuple
from dataclasses import dataclass

@dataclass
class CognitiveProfile:
    """–ö–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å –∏–Ω–¥–∏–≤–∏–¥–∞"""
    working_memory_span: float      # 2-12 chunks
    processing_speed: float         # 0.5-2.0 relative
    general_intelligence: float     # 0.5-2.0 relative  
    age: float                     # years
    education_years: float         # years
    domain_expertise: float        # 0-1 normalized
    health_status: float           # 0-1 normalized

@dataclass  
class MotivationalProfile:
    """–ú–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å"""
    intrinsic_interest: float      # 0-1
    external_motivation: float     # 0-1
    curiosity_drive: float         # 0-1
    personal_relevance: float      # 0-1
    goal_orientation: float        # 0-1

@dataclass
class OrganizationalProfile:
    """–ü—Ä–æ—Ñ–∏–ª—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π"""
    categorization_skill: float    # 0-1
    pattern_recognition: float     # 0-1
    schema_strength: float         # 0-1
    retrieval_efficiency: float    # 0-1
    knowledge_integration: float   # 0-1

class InformationCapacityModel:
    """–ü–æ–ª–Ω–∞—è –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏"""
    
    def __init__(self):
        self.base_capacity = 7.0  # Miller's magic number
        
    def calculate_memory_factor(self, cognitive: CognitiveProfile) -> float:
        """–§–∞–∫—Ç–æ—Ä –ø–∞–º—è—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π"""
        
        # Working Memory component
        wm_normalized = cognitive.working_memory_span / 7.0  # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫ Miller
        wm_factor = 0.8 + 0.4 * wm_normalized  # [0.8, 1.2]
        
        # Processing Speed component  
        speed_factor = 0.7 + 0.6 * cognitive.processing_speed  # [0.7, 1.9]
        
        # General Intelligence component
        g_factor = 0.6 + 0.8 * cognitive.general_intelligence  # [0.6, 1.4]
        
        # Age-related changes
        if cognitive.age <= 25:
            age_factor = 0.9 + 0.2 * (cognitive.age / 25)  # –†–∞–∑–≤–∏—Ç–∏–µ –¥–æ –ø–∏–∫–∞
        elif cognitive.age <= 60:
            age_factor = 1.1 - 0.1 * ((cognitive.age - 25) / 35)  # –°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å
        else:
            age_factor = 1.0 - 0.02 * (cognitive.age - 60)  # –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ
        
        # Education multiplier
        education_factor = 1.0 + 0.03 * cognitive.education_years
        
        # Domain expertise (—ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç)
        expertise_factor = 1.0 + 3.0 * (cognitive.domain_expertise ** 2)
        
        # Health impact
        health_factor = 0.5 + 0.5 * cognitive.health_status
        
        memory_factor = (
            wm_factor * speed_factor * g_factor * 
            age_factor * education_factor * expertise_factor * health_factor
        ) ** 0.5  # Geometric mean –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
        
        return max(0.2, min(5.0, memory_factor))
    
    def calculate_motivation_factor(self, motivation: MotivationalProfile) -> float:
        """–ú–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–∫—Ç–æ—Ä –µ–º–∫–æ—Å—Ç–∏"""
        
        # Weighted combination of motivational components
        motivation_score = (
            0.4 * motivation.intrinsic_interest +
            0.2 * motivation.external_motivation +
            0.2 * motivation.curiosity_drive +
            0.15 * motivation.personal_relevance +
            0.05 * motivation.goal_orientation
        )
        
        # Sigmoid activation for non-linear effect
        # –ü—Ä–∏ –Ω–∏–∑–∫–æ–π –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –µ–º–∫–æ—Å—Ç—å —Å–µ—Ä—å–µ–∑–Ω–æ —Å–Ω–∏–∂–∞–µ—Ç—Å—è
        if motivation_score < 0.3:
            motivation_factor = 0.3 + 0.7 * (motivation_score / 0.3)
        else:
            motivation_factor = 1.0 + 1.5 * ((motivation_score - 0.3) / 0.7)
        
        return max(0.1, min(2.5, motivation_factor))
    
    def calculate_organization_factor(self, organization: OrganizationalProfile) -> float:
        """–§–∞–∫—Ç–æ—Ä –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π"""
        
        # Categorization skills - —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        categorization_effect = 1.0 + 0.5 * organization.categorization_skill
        
        # Pattern recognition - –≤—ã—è–≤–ª–µ–Ω–∏–µ –∑–∞–∫–æ–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç–µ–π
        pattern_effect = 1.0 + 0.4 * organization.pattern_recognition
        
        # Schema strength - —Å–∏–ª–∞ –∫–æ–Ω—Ü–µ–ø—Ç—É–∞–ª—å–Ω—ã—Ö —Å—Ö–µ–º
        schema_effect = 1.0 + 0.6 * organization.schema_strength
        
        # Retrieval efficiency - —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∏–∑–≤–ª–µ—á–µ–Ω–∏—è
        retrieval_effect = 1.0 + 0.3 * organization.retrieval_efficiency
        
        # Knowledge integration - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –∑–Ω–∞–Ω–∏–π
        integration_effect = 1.0 + 0.7 * organization.knowledge_integration
        
        # Multiplicative model (–≤—Å–µ —Ñ–∞–∫—Ç–æ—Ä—ã –≤–∞–∂–Ω—ã)
        organization_factor = (
            categorization_effect * pattern_effect * schema_effect * 
            retrieval_effect * integration_effect
        ) ** 0.2  # Geometric mean
        
        return max(0.5, min(3.0, organization_factor))
    
    def calculate_total_capacity(
        self,
        cognitive: CognitiveProfile,
        motivation: MotivationalProfile, 
        organization: OrganizationalProfile,
        context_factors: Dict[str, float] = None
    ) -> Dict[str, float]:
        """
        –†–∞—Å—á–µ—Ç –æ–±—â–µ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏
        """
        # –ë–∞–∑–æ–≤—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã
        memory_factor = self.calculate_memory_factor(cognitive)
        motivation_factor = self.calculate_motivation_factor(motivation)
        organization_factor = self.calculate_organization_factor(organization)
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç—É–∞–ª—å–Ω—ã–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
        context_multiplier = 1.0
        if context_factors:
            stress_level = context_factors.get('stress', 0.0)
            time_pressure = context_factors.get('time_pressure', 0.0)
            distractions = context_factors.get('distractions', 0.0)
            
            # –°—Ç—Ä–µ—Å—Å —Å–Ω–∏–∂–∞–µ—Ç –µ–º–∫–æ—Å—Ç—å –Ω–µ–ª–∏–Ω–µ–π–Ω–æ
            stress_effect = 1.0 - 0.5 * (stress_level ** 2)
            
            # –í—Ä–µ–º–µ–Ω–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ
            pressure_effect = 1.0 - 0.3 * time_pressure
            
            # –û—Ç–≤–ª–µ—á–µ–Ω–∏—è
            distraction_effect = 1.0 - 0.4 * distractions
            
            context_multiplier = stress_effect * pressure_effect * distraction_effect
        
        # –ò—Ç–æ–≥–æ–≤–∞—è –µ–º–∫–æ—Å—Ç—å
        total_capacity = (
            self.base_capacity * 
            memory_factor * 
            motivation_factor * 
            organization_factor * 
            context_multiplier
        )
        
        return {
            'total_capacity': max(0.5, min(50.0, total_capacity)),
            'memory_factor': memory_factor,
            'motivation_factor': motivation_factor,
            'organization_factor': organization_factor,
            'context_multiplier': context_multiplier,
            'base_capacity': self.base_capacity
        }
```

---

## ‚ö° –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏

### 1. –ó–∞—Ä—è–¥–∫–∞ –∏ —Ä–∞–∑—Ä—è–¥–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä–∞

```python
class InformationCapacitor:
    """–ú–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä–∞"""
    
    def __init__(self, capacity: float, initial_charge: float = 0):
        self.C_info = capacity
        self.Q_info = initial_charge  # –ù–∞–∫–æ–ø–ª–µ–Ω–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        self.U_info = initial_charge / capacity if capacity > 0 else 0
        
    def charge(self, voltage_source: float, resistance: float, time_step: float) -> Dict[str, float]:
        """
        –ü—Ä–æ—Ü–µ—Å—Å –∑–∞—Ä—è–¥–∫–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä–∞
        –ê–Ω–∞–ª–æ–≥ RC-—Ü–µ–ø–∏: V_C(t) = V_source √ó (1 - e^(-t/RC))
        """
        RC_constant = resistance * self.C_info
        
        # –ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è –Ω–∞ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä–µ
        dU_dt = (voltage_source - self.U_info) / RC_constant
        self.U_info += dU_dt * time_step
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞—Ä—è–¥–∞
        self.Q_info = self.C_info * self.U_info
        
        # –¢–æ–∫ –∑–∞—Ä—è–¥–∫–∏
        I_charging = (voltage_source - self.U_info) / resistance
        
        return {
            'voltage': self.U_info,
            'charge': self.Q_info,
            'current': I_charging,
            'time_constant': RC_constant,
            'charge_percentage': self.U_info / voltage_source if voltage_source > 0 else 0
        }
    
    def discharge(self, resistance: float, time_step: float) -> Dict[str, float]:
        """
        –ü—Ä–æ—Ü–µ—Å—Å —Ä–∞–∑—Ä—è–¥–∫–∏ (–∑–∞–±—ã–≤–∞–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏)
        V_C(t) = V_initial √ó e^(-t/RC)
        """
        RC_constant = resistance * self.C_info
        
        # –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Ä–∞–∑—Ä—è–¥–∫–∞
        decay_factor = np.exp(-time_step / RC_constant)
        self.U_info *= decay_factor
        self.Q_info = self.C_info * self.U_info
        
        # –¢–æ–∫ —Ä–∞–∑—Ä—è–¥–∫–∏
        I_discharge = -self.U_info / resistance
        
        return {
            'voltage': self.U_info,
            'charge': self.Q_info,
            'current': I_discharge,
            'retention_factor': decay_factor
        }
    
    def frequency_response(self, omega: float) -> complex:
        """
        –ß–∞—Å—Ç–æ—Ç–Ω–∞—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä–∞
        Z_C = 1/(jœâC)
        """
        if omega == 0:
            return complex(float('inf'), 0)  # DC –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
        else:
            return complex(0, -1 / (omega * self.C_info))
```

### 2. –ö—Ä–∏–≤—ã–µ –æ–±—É—á–µ–Ω–∏—è –∏ –∑–∞–±—ã–≤–∞–Ω–∏—è

```python
def learning_curve_model(
    learning_sessions: List[Dict], 
    capacity_model: InformationCapacityModel,
    individual_profile: Tuple[CognitiveProfile, MotivationalProfile, OrganizationalProfile]
) -> Dict:
    """
    –ú–æ–¥–µ–ª—å –∫—Ä–∏–≤–æ–π –æ–±—É—á–µ–Ω–∏—è —Å —É—á–µ—Ç–æ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏
    """
    cognitive, motivation, organization = individual_profile
    
    # –†–∞—Å—á–µ—Ç —Ç–µ–∫—É—â–µ–π –µ–º–∫–æ—Å—Ç–∏
    capacity_result = capacity_model.calculate_total_capacity(cognitive, motivation, organization)
    total_capacity = capacity_result['total_capacity']
    
    # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä
    info_capacitor = InformationCapacitor(total_capacity)
    
    learning_progress = []
    cumulative_knowledge = 0
    
    for session in learning_sessions:
        information_voltage = session['content_quality']
        cognitive_resistance = session['difficulty'] / cognitive.processing_speed
        session_duration = session['duration_hours']
        
        # –ü—Ä–æ—Ü–µ—Å—Å –æ–±—É—á–µ–Ω–∏—è (–∑–∞—Ä—è–¥–∫–∞)
        for time_step in np.arange(0, session_duration, 0.1):  # 6-–º–∏–Ω—É—Ç–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
            charge_result = info_capacitor.charge(
                voltage_source=information_voltage,
                resistance=cognitive_resistance,
                time_step=0.1
            )
        
        # –ú–µ–∂—Å–µ—Å—Å–∏–æ–Ω–Ω–æ–µ –∑–∞–±—ã–≤–∞–Ω–∏–µ
        if 'time_between_sessions' in session:
            forget_time = session['time_between_sessions']
            for time_step in np.arange(0, forget_time, 0.5):  # 30-–º–∏–Ω—É—Ç–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
                discharge_result = info_capacitor.discharge(
                    resistance=cognitive_resistance * 2,  # –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –∑–∞–±—ã–≤–∞–Ω–∏—é
                    time_step=0.5
                )
        
        learning_progress.append({
            'session': len(learning_progress) + 1,
            'accumulated_knowledge': info_capacitor.Q_info,
            'knowledge_voltage': info_capacitor.U_info,
            'capacity_utilization': info_capacitor.Q_info / total_capacity,
            'learning_efficiency': charge_result.get('charge_percentage', 0)
        })
    
    return {
        'learning_trajectory': learning_progress,
        'final_knowledge_level': info_capacitor.Q_info,
        'capacity_utilization': info_capacitor.Q_info / total_capacity,
        'optimal_capacity': total_capacity
    }

def forgetting_curve_ebbinghaus_extended(
    initial_knowledge: float,
    time_hours: np.ndarray,
    individual_resistance: float,
    rehearsal_schedule: List[float] = None
) -> np.ndarray:
    """
    –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∫—Ä–∏–≤–∞—è –∑–∞–±—ã–≤–∞–Ω–∏—è –≠–±–±–∏–Ω–≥–∞—É–∑–∞ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç—å—é
    """
    # –ë–∞–∑–æ–≤–∞—è —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å –∑–∞–±—ã–≤–∞–Ω–∏—è
    base_retention = initial_knowledge * np.exp(-time_hours / (individual_resistance * 24))
    
    # –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π (rehearsal)
    if rehearsal_schedule:
        retention_with_rehearsal = base_retention.copy()
        for rehearsal_time in rehearsal_schedule:
            # –ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à–∏–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω–¥–µ–∫—Å
            time_idx = np.argmin(np.abs(time_hours - rehearsal_time))
            
            # –ë—É—Å—Ç–∏–Ω–≥ –ø–∞–º—è—Ç–∏ –æ—Ç –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è
            boost_factor = 1.5 * np.exp(-(time_hours[time_idx:] - rehearsal_time) / 12)
            retention_with_rehearsal[time_idx:] *= (1 + boost_factor)
        
        return np.minimum(retention_with_rehearsal, initial_knowledge)  # Cap at initial level
    
    return base_retention
```

---

## üî¨ –≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è

### –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ 1: –ï–º–∫–æ—Å—Ç–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ AC —Ä–µ–∂–∏–º–µ
```python
def test_capacitive_frequency_effects():
    """
    –¢–µ—Å—Ç —á–∞—Å—Ç–æ—Ç–Ω–æ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏
    """
    capacity = 5.0  # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –µ–º–∫–æ—Å—Ç—å
    frequencies = np.logspace(-2, 2, 50)  # 0.01 to 100 Hz
    
    impedances = []
    for freq in frequencies:
        omega = 2 * np.pi * freq
        Z_C = 1 / (1j * omega * capacity)
        impedances.append(abs(Z_C))
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: –í—ã—Å–æ–∫–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –Ω–∞ –Ω–∏–∑–∫–∏—Ö —á–∞—Å—Ç–æ—Ç–∞—Ö
    assert impedances[0] > impedances[-1] * 100
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: –û–±—Ä–∞—Ç–Ω–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç —á–∞—Å—Ç–æ—Ç—ã
    log_freq = np.log10(frequencies)
    log_impedance = np.log10(impedances)
    slope, _ = np.polyfit(log_freq, log_impedance, 1)
    assert slope < -0.8  # –ü—Ä–∏–±–ª–∏–∂–µ–Ω–Ω–æ -1 –¥–ª—è –∏–¥–µ–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω–¥–µ–Ω—Å–∞—Ç–æ—Ä–∞
```

### –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ 2: RC –ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è –≤—Ä–µ–º–µ–Ω–∏
```python
def test_information_time_constant():
    """
    –¢–µ—Å—Ç –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –≤—Ä–µ–º–µ–Ω–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π RC-—Ü–µ–ø–∏
    """
    C_info = 10.0  # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –µ–º–∫–æ—Å—Ç—å
    R_info = 2.0   # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ
    tau_expected = R_info * C_info  # 20.0
    
    # –°–∏–º—É–ª—è—Ü–∏—è –∑–∞—Ä—è–¥–∫–∏
    capacitor = InformationCapacitor(C_info)
    time_steps = np.arange(0, 100, 0.1)
    voltages = []
    
    for t in time_steps:
        result = capacitor.charge(voltage_source=1.0, resistance=R_info, time_step=0.1)
        voltages.append(result['voltage'])
    
    # –ù–∞–π—Ç–∏ –≤—Ä–µ–º—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è 63.2% –æ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
    target_voltage = 0.632
    time_63_idx = np.argmin(np.abs(np.array(voltages) - target_voltage))
    tau_measured = time_steps[time_63_idx]
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: œÑ –∏–∑–º–µ—Ä–µ–Ω–Ω–æ–µ ‚âà œÑ —Ä–∞—Å—á–µ—Ç–Ω–æ–µ
    assert abs(tau_measured - tau_expected) < tau_expected * 0.1
```

### –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ 3: –ö—Ä–∏–≤–∞—è –∑–∞–±—ã–≤–∞–Ω–∏—è
```python
def test_forgetting_curve_validation():
    """
    –í–∞–ª–∏–¥–∞—Ü–∏—è –∫—Ä–∏–≤–æ–π –∑–∞–±—ã–≤–∞–Ω–∏—è –ø—Ä–æ—Ç–∏–≤ –¥–∞–Ω–Ω—ã—Ö –≠–±–±–∏–Ω–≥–∞—É–∑–∞
    """
    # –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –≠–±–±–∏–Ω–≥–∞—É–∑–∞ (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω—ã–µ)
    ebbinghaus_data = {
        'time_hours': [0, 1, 9, 24, 48, 144, 720],  # 0h, 1h, 9h, 1d, 2d, 6d, 30d
        'retention': [1.0, 0.56, 0.36, 0.33, 0.28, 0.25, 0.21]
    }
    
    # –ù–∞—à–∞ –º–æ–¥–µ–ª—å
    time_array = np.array(ebbinghaus_data['time_hours'])
    modeled_retention = forgetting_curve_ebbinghaus_extended(
        initial_knowledge=1.0,
        time_hours=time_array,
        individual_resistance=1.2  # –ü–æ–¥–±–∏—Ä–∞–µ–º—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
    )
    
    # –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    correlation = np.corrcoef(ebbinghaus_data['retention'], modeled_retention)[0,1]
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: –í—ã—Å–æ–∫–∞—è –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    assert correlation > 0.9
```

---

## üéØ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è

### 1. –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ —Å–∏—Å—Ç–µ–º—ã
```python
def adaptive_curriculum_design(
    student_profiles: List[Tuple[CognitiveProfile, MotivationalProfile, OrganizationalProfile]],
    course_material: Dict[str, any],
    learning_objectives: List[str]
) -> Dict[str, any]:
    """
    –î–∏–∑–∞–π–Ω –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ –∫—É—Ä—Å–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏ —Å—Ç—É–¥–µ–Ω—Ç–æ–≤
    """
    capacity_model = InformationCapacityModel()
    optimized_curriculum = {}
    
    for student_id, (cognitive, motivation, organization) in enumerate(student_profiles):
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏
        capacity_result = capacity_model.calculate_total_capacity(cognitive, motivation, organization)
        student_capacity = capacity_result['total_capacity']
        
        # –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –æ–±—ä–µ–º–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞
        max_info_per_session = student_capacity * 0.8  # 80% –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞
        
        # –†–∞—Å—á–µ—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
        material_complexity = course_material['complexity_score']
        cognitive_resistance = material_complexity / cognitive.processing_speed
        
        # RC –ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤
        time_constant = cognitive_resistance * student_capacity
        optimal_interval = time_constant * 2.3  # 90% –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –µ–º–∫–æ—Å—Ç–∏
        
        optimized_curriculum[f'student_{student_id}'] = {
            'info_per_session': max_info_per_session,
            'session_interval_hours': optimal_interval,
            'total_sessions': len(learning_objectives),
            'personalized_difficulty': material_complexity * (cognitive.processing_speed ** 0.5),
            'motivation_boosters': design_motivation_interventions(motivation)
        }
    
    return optimized_curriculum

def design_motivation_interventions(motivation: MotivationalProfile) -> List[str]:
    """–î–∏–∑–∞–π–Ω –º–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∏–Ω—Ç–µ—Ä–≤–µ–Ω—Ü–∏–π"""
    interventions = []
    
    if motivation.intrinsic_interest < 0.5:
        interventions.append("gamification_elements")
        interventions.append("curiosity_gaps")
    
    if motivation.external_motivation < 0.5:
        interventions.append("progress_badges")
        interventions.append("social_recognition")
    
    if motivation.personal_relevance < 0.5:
        interventions.append("real_world_applications")
        interventions.append("career_connections")
    
    return interventions
```

### 2. –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤
```python
def design_information_interface(
    user_capacity_profile: Dict[str, float],
    content_hierarchy: Dict[str, any],
    interaction_goals: List[str]
) -> Dict[str, any]:
    """
    –î–∏–∑–∞–π–Ω –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ —Å —É—á–µ—Ç–æ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    user_capacity = user_capacity_profile['total_capacity']
    
    # –ü—Ä–∏–Ω—Ü–∏–ø—ã –¥–∏–∑–∞–π–Ω–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–º–∫–æ—Å—Ç–∏
    design_principles = {
        'max_elements_per_screen': min(int(user_capacity * 0.6), 12),
        'information_hierarchy_levels': min(int(user_capacity * 0.3), 5),
        'cognitive_load_budget': user_capacity * 0.7,  # –û—Å—Ç–∞–≤–ª—è–µ–º —Ä–µ–∑–µ—Ä–≤
        'chunking_strategy': 'hierarchical' if user_capacity > 10 else 'sequential'
    }
    
    # –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
    content_chunks = []
    current_chunk_load = 0
    current_chunk = []
    
    for item in content_hierarchy['items']:
        item_complexity = item['cognitive_weight']
        
        if current_chunk_load + item_complexity <= design_principles['cognitive_load_budget']:
            current_chunk.append(item)
            current_chunk_load += item_complexity
        else:
            content_chunks.append(current_chunk)
            current_chunk = [item]
            current_chunk_load = item_complexity
    
    if current_chunk:
        content_chunks.append(current_chunk)
    
    return {
        'design_principles': design_principles,
        'content_organization': content_chunks,
        'estimated_cognitive_load': sum(chunk['cognitive_weight'] for chunk in content_chunks[0] if content_chunks),
        'capacity_utilization': (sum(chunk['cognitive_weight'] for chunk in content_chunks[0] if content_chunks) / user_capacity) if content_chunks else 0
    }
```

### 3. –ö–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏—è–º–∏
```python
def corporate_knowledge_capacity_audit(
    employee_profiles: List[CognitiveProfile],
    knowledge_domains: List[str],
    information_flow_requirements: Dict[str, float]
) -> Dict[str, any]:
    """
    –ê—É–¥–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏ –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
    """
    capacity_model = InformationCapacityModel()
    
    # –ê–Ω–∞–ª–∏–∑ –µ–º–∫–æ—Å—Ç–∏ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
    total_capacity = 0
    capacity_distribution = []
    
    for profile in employee_profiles:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ä–µ–¥–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
        avg_motivation = MotivationalProfile(0.7, 0.6, 0.6, 0.8, 0.7)
        avg_organization = OrganizationalProfile(0.6, 0.6, 0.6, 0.6, 0.6)
        
        employee_capacity = capacity_model.calculate_total_capacity(
            profile, avg_motivation, avg_organization
        )['total_capacity']
        
        total_capacity += employee_capacity
        capacity_distribution.append(employee_capacity)
    
    # –ê–Ω–∞–ª–∏–∑ —É–∑–∫–∏—Ö –º–µ—Å—Ç
    required_capacity = sum(information_flow_requirements.values())
    capacity_surplus = total_capacity - required_capacity
    
    # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    recommendations = []
    
    if capacity_surplus < 0:
        recommendations.append("increase_team_size")
        recommendations.append("reduce_information_complexity")
        recommendations.append("implement_automation")
    
    elif capacity_surplus > total_capacity * 0.5:
        recommendations.append("increase_information_throughput")
        recommendations.append("add_complex_projects")
        recommendations.append("cross_training_opportunities")
    
    return {
        'total_organizational_capacity': total_capacity,
        'required_capacity': required_capacity,
        'capacity_utilization': required_capacity / total_capacity,
        'capacity_distribution': {
            'mean': np.mean(capacity_distribution),
            'std': np.std(capacity_distribution),
            'min': np.min(capacity_distribution),
            'max': np.max(capacity_distribution)
        },
        'recommendations': recommendations,
        'bottleneck_domains': [domain for domain, req in information_flow_requirements.items() 
                             if req > np.mean(capacity_distribution)]
    }
```

---

## üìà –í–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω—ã–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏

### –ö–æ–ª–∏—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏:
1. **–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å WM —Ç–µ—Å—Ç–∞–º–∏**: r > 0.7 –º–µ–∂–¥—É C_info –∏ working memory span
2. **–í—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã**: RC –º–æ–¥–µ–ª—å –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞—Ç—å –≤—Ä–µ–º—è –æ–±—É—á–µ–Ω–∏—è ¬±20%
3. **–ö—Ä–∏–≤—ã–µ –∑–∞–±—ã–≤–∞–Ω–∏—è**: –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å –¥–∞–Ω–Ω—ã–º–∏ –≠–±–±–∏–Ω–≥–∞—É–∑–∞ > 0.85
4. **–ß–∞—Å—Ç–æ—Ç–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã**: –û–±—Ä–∞—Ç–Ω–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç —á–∞—Å—Ç–æ—Ç—ã –¥–ª—è AC –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞

### –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏:
1. **–ù–µ–π—Ä–æ–Ω–Ω–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≥–∏–ø–ø–æ–∫–∞–º–ø–∞ –∏ PFC
2. **–†–∞–∑–≤–∏—Ç–∏–π–Ω–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –≤–æ–∑—Ä–∞—Å—Ç–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π
3. **–ö–ª–∏–Ω–∏—á–µ—Å–∫–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö –Ω–∞—Ä—É—à–µ–Ω–∏–π
4. **–û–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å**: –£–ª—É—á—à–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ–±—É—á–µ–Ω–∏—è

---

## üöÄ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∑–∞–∫–æ–Ω–æ–º –û–º–∞

### –ü–æ–ª–Ω–∞—è RLC –º–æ–¥–µ–ª—å:
```python
def complete_information_circuit(
    U_source: float,
    R_info: float, 
    L_info: float,
    C_info: float,
    frequency: float = 0,
    time_domain: bool = False
) -> Dict[str, any]:
    """
    –ü–æ–ª–Ω–∞—è –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π RLC —Ü–µ–ø–∏
    """
    omega = 2 * np.pi * frequency if frequency > 0 else 0
    
    if time_domain and frequency == 0:
        # –ü–µ—Ä–µ—Ö–æ–¥–Ω–æ–π –ø—Ä–æ—Ü–µ—Å—Å –≤ RLC —Ü–µ–ø–∏
        # –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–µ—Å–∫–æ–µ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ: s¬≤ + (R/L)s + 1/(LC) = 0
        discriminant = (R_info / L_info) ** 2 - 4 / (L_info * C_info)
        
        if discriminant > 0:
            # –ê–ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º
            s1 = (-R_info / L_info + np.sqrt(discriminant)) / 2
            s2 = (-R_info / L_info - np.sqrt(discriminant)) / 2
            response_type = "overdamped"
        elif discriminant == 0:
            # –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º
            s1 = s2 = -R_info / (2 * L_info)
            response_type = "critically_damped"
        else:
            # –ö–æ–ª–µ–±–∞—Ç–µ–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
            alpha = R_info / (2 * L_info)
            omega_d = np.sqrt(1 / (L_info * C_info) - alpha ** 2)
            response_type = "underdamped"
            
        return {
            'response_type': response_type,
            'damping_factor': R_info / (2 * np.sqrt(L_info / C_info)),
            'natural_frequency': 1 / np.sqrt(L_info * C_info),
            'time_constant': 2 * L_info / R_info
        }
    
    else:
        # –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑
        Z_total = complex(R_info, omega * L_info - 1 / (omega * C_info) if omega > 0 else -float('inf'))
        
        if abs(Z_total) > 0:
            I_info = U_source / Z_total
            V_R = I_info * R_info
            V_L = I_info * complex(0, omega * L_info)
            V_C = I_info * complex(0, -1 / (omega * C_info)) if omega > 0 else 0
        else:
            I_info = V_R = V_L = V_C = 0
        
        return {
            'current': abs(I_info),
            'current_phase': np.angle(I_info),
            'impedance': abs(Z_total),
            'voltage_R': abs(V_R),
            'voltage_L': abs(V_L),
            'voltage_C': abs(V_C),
            'power_factor': np.cos(np.angle(Z_total)),
            'resonance': abs(omega * L_info - 1 / (omega * C_info)) < 0.1 * R_info
        }
```

---

**–°—Ç–∞—Ç—É—Å:** ‚úÖ **–ó–ê–î–ê–ß–ê 2.1.3 –ó–ê–í–ï–†–®–ï–ù–ê**

–°–æ–∑–¥–∞–Ω–∞ –ø–æ–ª–Ω–∞—è –º–æ–¥–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –µ–º–∫–æ—Å—Ç–∏ —Å:
- ‚úÖ –ö–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã–º–∏ –æ—Å–Ω–æ–≤–∞–º–∏ (Working Memory, LTM, –º–æ—Ç–∏–≤–∞—Ü–∏—è, –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è)
- ‚úÖ –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ñ–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–µ–π C_info —Å –¥–µ—Ç–∞–ª—å–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–µ–π
- ‚úÖ –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ —Å–≤–æ–π—Å—Ç–≤–∞–º–∏ (–∑–∞—Ä—è–¥–∫–∞, —Ä–∞–∑—Ä—è–¥–∫–∞, —á–∞—Å—Ç–æ—Ç–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã)
- ‚úÖ –ú–æ–¥–µ–ª—è–º–∏ –æ–±—É—á–µ–Ω–∏—è –∏ –∑–∞–±—ã–≤–∞–Ω–∏—è
- ‚úÖ –≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–º–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è–º–∏
- ‚úÖ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è–º–∏ –≤ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–∏, UX, –∫–æ—Ä–ø–æ—Ä–∞—Ü–∏—è—Ö
- ‚úÖ –ü–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π —Å RLC –º–æ–¥–µ–ª—å—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ü–µ–ø–µ–π

–ì–æ—Ç–æ–≤–∞ –∫ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∏ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–º—É –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—é! üöÄ 